# -*- coding: utf-8 -*-
"""recursion_ejemplos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K_WogPxFvnIqxYI_qAIApgqpcQGwcz4q
"""

# recursion sin acumulador

def factorial(n):
  if n == 0:
    return 1
  return n*factorial(n-1)
print(factorial(5)) # 120

# recursion con acumulador

def factorial_tail(n, acumulador=1):
  if n == 0:
    return acumulador
  return factorial_tail(n-1, n*acumulador)
print(factorial_tail(5)) # 120

# recursion con resultado en el cuerpo

def factorial_body(n):
  resultado = 1
  if n > 0:
    resultado = n*factorial_body(n-1)
  return resultado
print(factorial_body(5)) # 120

def factorial(n):
  assert isinstance(n, int) and n >= 0, "Error, n debe ser positivo"
  if n == 0:
    return 1
  return n*factorial(n-1)
print(factorial(5)) # 120

def contar_digitos(n):
  if n == 0:
    return 0
  return 1+contar_digitos(n//10)
print(contar_digitos(41156)) # 5

# palabra al reves de fin a inicio

def palabra_alreves(p1):
  if len(p1) == 1:
    return p1
  return p1[-1]+palabra_alreves(p1[:-1])
print(palabra_alreves("chao")) # oahc

# palabra al reves con el indice

def palabra_alreves(p1, index=0):
  if index == len(p1):
    return ""
  return palabra_alreves(p1, index+1)+p1[index]
print(palabra_alreves("chao")) # oahc

def palabra_alreves(p1, index=0, pr=""):
  if index == len(p1):
    return pr
  print("pr ->", pr)
  print(". p1[index]", p1[index])
  return palabra_alreves(p1, index+1, p1[index]+pr)
print(palabra_alreves("chao")) # oahc

# palabra palindrome sin indices

def palabra_palindrome(p1):
  if len(p1) == 1:
    return True
  if p1[-1] == p1[0]:
    # llamado recursivo
    return palabra_palindrome(p1[1:-1])
  else:
    # caso base
    return False
print(palabra_palindrome("rotor")) # True

# palabra palindrome con indices

def palabra_palindrome(p1, indice1=-1, indice2=-1):
  if indice1 == -1 and indice2 == -1:
    indice1 = 0
    indice = len(p1) -1
  print("indice1 -> ", indice1)
  print("indice2 -> ", indice2)
  # caso base
  if indice1 == indice2 or indice2 < indice1:
    return True
  if p1[indice1] == p1[indice2]:
    # llamado recursivo
    return palabra_palindrome(p1, indice1+1, indice2-1)
  else:
    # caso base
    return False
print(palabra_palindrome("rotor")) # True

# reversar lista

def reversar_lista(l1):
  if len(l1) == 1:
    return l1 # l1[0] suma todos los valores
  return [l1[-1]] + reversar_lista(l1[:-1])
l1 = [5,7,9,13]
print(l1)
print(reversar_lista(l1))

# reversar lista con indices

def reversar_lista(l1,indice=0,lr=[]):
  if indice == len(l1):
    return lr
  return reversar_lista(l1,indice+1,[l1[indice]]+lr)
l1 = [5,7,9,13]
print(l1)
print(reversar_lista(l1))

def busqueda_binaria(l1, obj, i_low = -1, i_high= -1):

  if i_low == -1 and i_high == -1:
    i_low = 0
    i_high = len(l1) -1

  print("i_low :",i_low)
  print("i_high :",i_high)
  i_med = (i_low + i_high)//2
  print("i_med :",i_med)

  if l1[i_med] == obj:
    return "el objetivo fue encontrado en la posicion: " + str(i_med)

  if i_low > i_high:
    return "el objetivo NO fue encontrado"


  if obj < l1[i_med]:
    #busqueda en la primera mitad
    print("obj < l1[i_med]")
    return busqueda_binaria(l1, obj, i_low, i_med -1)
  elif obj > l1[i_med]:
    #busqueda en la segunda mitad
    print("obj > l1[i_med]")
    return busqueda_binaria(l1, obj, i_med + 1, i_high)

# contador de vocales y consonantes

l1 = [1,3,5,7,9,11,23,26]
v1 = 3
v2 = 23
v3 = 14
print(f"el valor {v1} : {busqueda_binaria(l1,v1)}")
#print(f"el valor {v2} : {busqueda_binaria(l1,v2)}")
#print(f"el valor {v3} : {busqueda_binaria(l1,v3)}")

def contarvocycons(p1, index=0,contv=0, contc=0):

  if index == len(p1):

    if contv == contc:
      return "Cantidades Iguales!"
    elif contv > contc:
      return "Mas vocales!"
    else:
      return "Mas consonantes!"

  vocales = ["a","e","i","o","u"]

  #print("p1[index]",p1[index])
  #print("contv",contv)
  #print("contc",contc)
  if p1[index].isalpha():
    if p1[index] in vocales:
      return contarvocycons(p1, index+1,contv+1, contc)
    else:
      return contarvocycons(p1, index+1,contv, contc+1)
  else:
    return "Error, entrada no valida, no es alfabetica"

p1 = "arnulfo"
p2 = "avioneta"
p3 = "casa"
p4 = "ar6%ca"

print(f"la palabra {p1} tiene {contarvocycons(p1)}")
#print(f"la palabra {p2} tiene {contarvocycons(p2)}")
#print(f"la palabra {p3} tiene {contarvocycons(p3)}")
print(f"la palabra {p4} tiene {contarvocycons(p4)}")

def contarvocycons(p1):

  vocales = ["a","e","i","o","u"]

  def auxcontarvocycons(p1, vocales, index=0,contv=0, contc=0):
    if index == len(p1):
      if contv == contc:
        return "Cantidades Iguales!"
      elif contv > contc:
        return "Mas vocales!"
      else:
        return "Mas consonantes!"


    if p1[index].isalpha():
        if p1[index] in vocales:
          return auxcontarvocycons(p1, vocales, index+1,contv+1, contc)
        else:
          return auxcontarvocycons(p1, vocales, index+1,contv, contc+1)
    else:
        return "Error, entrada no valida, no es alfabetica"

  return auxcontarvocycons(p1,vocales)

p1 = "arnulfo"
p2 = "avioneta"
p3 = "casa"
p4 = "ar6%ca"

print(f"la palabra {p1} tiene {contarvocycons(p1)}")

# valor maximo de una lista, sin ordenar

def buscarmax(l1):

  if len(l1) == 1:
    return l1[0]

  return max(l1[0],buscarmax(l1[1:]))

lista = [11,2,4,7,19,3]
print("Lista :", lista)
print(f"el valor maximo de la lista es {buscarmax(lista)}")

def buscarmax2(l1,index=0):

  if len(l1)-1 == index:
    return l1[index]

  return max(l1[index],buscarmax2(l1,index+1))

lista = [11,2,4,7,19,3]
print("Lista :", lista)
print(f"el valor maximo de la lista es {buscarmax2(lista)}")

def buscarmax3(l1,index=0):

  if len(l1)-1 == index:
    return l1[index]

  resto = buscarmax3(l1,index+1)
  return l1[index] if l1[index] > resto else resto

lista = [11,24,4,7,19,3]
print("Lista :", lista)
print(f"el valor maximo de la lista es {buscarmax3(lista)}")

# Multiplos de un numero

def contarmultiplos(num,cont=0):

  if num == 0:
    return cont

  #print("num :",num)
  digito = num%10
  #print("digito :", digito)

  if digito == 0:
    return contarmultiplos(num//10,cont)
  if digito % 2 == 0 and digito % 4 == 0:
    return contarmultiplos(num//10,cont+1)
  else:
    return contarmultiplos(num//10,cont)

num1 = 34523
num2 = 84842
num3 = 60021

print(f"el numero {num1} tiene: {contarmultiplos(num1)} digitos multiplos del 2 y 4")
print(f"el numero {num2} tiene: {contarmultiplos(num2)} digitos multiplos del 2 y 4")
print(f"el numero {num3} tiene: {contarmultiplos(num3)} digitos multiplos del 2 y 4")

num = 9
print(num//10)
print(num%10)

# Enteros de diagonal principal cuadrada son iguales en una matriz

# matriz

m1 = [[2,3,6],
      [9,2,6],
      [4,5,2]]

m2 = [[2,3,6],
      [9,2,6],
      [4,5,5]]

m3 = [[2,3,6,5,6],
      [9,2,6,4,7],
      [4,5,2,7,8],
      [4,5,5,2,2],
      [4,5,5,7,2]]

def validardiagonales(m1,i=0):

  if i == len(m1) -1 :
    return True

  print("i",i)
  if m1[i][i] == m1[i+1][i+1]:
    return validardiagonales(m1,i+1)
  else:
    return False

print(f"la matriz 1 tiene los valores en la diagonal iguales? {validardiagonales(m1)}")
print(f"la matriz 2 tiene los valores en la diagonal iguales? {validardiagonales(m2)}")
print(f"la matriz 3 tiene los valores en la diagonal iguales? {validardiagonales(m3)}")
